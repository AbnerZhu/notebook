[TOC]

# BLOGS

## [《如何阅读一本书》 —— 书评及内容纲要](https://program-think.blogspot.com/2013/04/how-to-read-book.html)

- 阅读的目的
  - 娱乐消遣；
  - 获取资讯。 只是获取信息， 只需要动用『记忆力』；
  - 增进理解力。 如果某本书的内容超出了你的理解力， 或者超出了你所熟悉的领域， 那么你就需要花一定的力气才能读懂。 这时， 光靠记忆力就远远不够了。 需要动用大脑的其它的能力（分析、 推理、 总结、 想象等）。 显然， 这种阅读过程伴随着更多的思考， 可以染给你的头脑提升到新的高度。

- 主动阅读 VS 被动阅读

  - 主动阅读。 带着问题去阅读， 要一边阅读一边思考；
  - 被动阅读。 在阅读过程中没有思考。

  如果阅读目的是『增进理解力』， 就是典型的主动阅读； 如果是为了 『娱乐消遣』， 基本上是被动阅读； 至于目的是『获取资讯』的阅读， 则两者兼而有之。

  如今大部分人只懂得 『被动阅读』， 主要原因有两个：

  - 教育体制。 当前教育缺少系统性地培养独立思维能力， 尤其是『[批判性思维](http://program-think.blogspot.com/2010/10/book-review-asking-right-questions.html)』的能力；
  - 快餐文化。 如今的网民， 大部分人把大部分的时间花在消遣性的阅读， 长期以往， 主动阅读的能力就逐渐退化。 这方面的危害， 微博客（microblog）尤甚 —— 微博客不但碎片化很严重， 而且助长了消遣性阅读的风气（[微博客的弊端](https://program-think.blogspot.com/2012/02/microblog-and-time-management.html)）。

  如何才能 『带着问题阅读』 呢？

  - 整体来说， 这本书到底在谈些什么？ 一定要想办法找出这本书的主题。 作者如何依次发展这个主体， 如何逐步从核心主题分解出从属的关键议题来。
  - 作者细部说了什么， 怎么说的？ 一定要想办法找出主要的想法、 声明与论点。 这些组合成作者想要传达的特殊讯息。
  - 这本书说得有道理吗？ 是全部有道理， 还是部分有道理？ 除非你能回到前两个问题， 否则你没法回答这个问题。 在你判断这本书是否有道理之前， 你必须要先了解这本书在说些什么才行。 然后， 等你了解了一本书， 如果你又读得很认真的话， 你会觉得有则认为这本书做个自己的判断。 光是知道作者的想法是不够的。
  - 这本书跟你有什么关系？ 如果这本书给了你一些咨询， 你一定要问问这些咨询有什么意义。 为什么这位作者会认为知道这件事很重要？ 你真的有必要去了解吗？ 如果这本书不只提供了咨询， 还启发了你， 就更有必要找出相关的、 更深的含义或建议， 以获得更多的启示。

- 阅读的层次

  为啥称『层次』而不称『类型』， 因为层次有『高低之分』， 而且层次之间是递进关系而不是并列关系 —— 上面的层次需要依赖下面层次的技能。

  - 基础阅读。 最基本的阅读层次。 只需要做到『读懂书籍字面上的意思』。 需要的技能仅仅是： 识字、 断句、 联系上下文等

  - 检视阅读。 即为 『略读』。 目的是在非常有限的时间内， 大致搞清楚一本书的内容和主题。 『略读』 有助于我们用尽可能短的时间， 判断一本书的优劣。 这样就避免在烂熟上浪费太多时间。 另外， 在后续的 「主题阅读」 层次， 也非常依赖 「检视阅读」 的能力。

  - 分析阅读。 即为 「精读」。 只有对有价值的书， 才只读花力气做 「分析阅读」。 「烂书或平庸的书」 是没有这种待遇的。 分析阅读包括如下几个阶段。

    - 第一阶段 —— 这本书在谈些什么？ 

      - 依照书本的种类和主题做分类；
      - 用最简短的句子说出整本书在谈些什么；
      - 按照顺序与关系， 列出全书的重要部分。 将全书的纲要拟出来以后， 再将各个部分的纲要也一一列出；
      - 找出作者在问的问题， 或者作者想要解决的问题。

    - 第二阶段 —— 诠释整本书的内容。

      - 找出重要的， 关键性的词汇， 透过他们与作者达成共识；
      - 从最重要的句子里抓出作者的重要主旨；
      - 找出作者在论述些什么， 重新架构这些论述的因果关系， 以明白作者的主张；
      - 搞清楚作者已解决了哪些问题， 还有哪些是未解决的。 在未解决的问题中， 哪些作者认为自己是无法解决的。

    - 第三阶段 —— 评价这本书。

      - 除非你已掌握某本书的架构， 也能诠释整本书， 否则不要轻易评论；
      - 不要争强好胜， 非辩到底不可；
      - 在说出评论之前， 要能区分书中的「事实」与「观点」。

      要作出**批判性**的评价， 需要做到如下几点：

      - 证明作者的知识不足；
      - 证明作者的知识有误；
      - 证明作者的逻辑有误（[常见逻辑谬误](http://program-think.blogspot.com/2011/03/logical-fallacies.html)）；
      - 证明作者的分析与理由不够完善。

    另外， 在分析阅读时， 利用外在的工具和资源（比如工具书、 百科全书、 字典等） 进行[辅助阅读](https://program-think.blogspot.com/2013/03/internet-resource-discovery-1.html)。

  - 主题阅读。 为了研究某个主题， 阅读跟该主题相关的多本书籍。 这种阅读主要包括 5 个步骤：

    - 找到这几本书的相关章节。 检视阅读；
    - 带引作者与你达成共识。 分析阅读的第二阶段；
    - 理清问题。 列出一些问题， 然后看看这几本书能否回答这些问题；
    - 界定议题。 如果基本不同的书籍都能够回答同一个问题， 并且答案有差异。 那么， 可以根据答案的差异、 作者的情况， 进而判断这个问题的价值。
    - 分析讨论。 找到有价值的问题之后， 就需要通过自己的综合分析， 思考一下： [为什么](https://program-think.blogspot.tw/2009/02/study-technology-in-three-steps.html)这几本书的作者对同一个问题会有不同的答案。 如果能想明白[为什么](https://program-think.blogspot.tw/2012/03/think-what-how-why.html)， 那么对该主题所处的领域， 就有了更深的理解。

- 如何读不同类型的书籍

  - 实用型书
  - 想象文学
  - 读故事、 戏剧、 诗歌
  - 历史书
  - 科学和数学
  - 哲学
  - 社会科学

- 阅读与心智的成长

  - 好书能带了什么帮助？ 读一本好书，却会让你的努力有所回报。最好的书对你的回馈也最多。当然，这样的回馈分成两种：第一，当你成功地阅读了一本难读的好书之后，你的阅读技巧必然增进了。第二（长期来说这一点更重要）一本好书能教你了解这个世界以及你自己。你不只更懂得如何读得更好，还更懂得生命。你变得更有智慧，而不只是更有知识—像只提供讯息的书所形成的那样。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。只提供讯息的书，带给你“知识”；而真正的好书带给你“智慧”。至于消遣性的书，既不会给你知识，也不会给你智慧。

  - 书籍的金字塔。 书籍好坏是符合[二八原理](http://program-think.blogspot.com/2009/02/80-20-principle-0-overview.html)的. 关于书籍的金字塔， 包括三层

    - 第一层。 99% 的书籍会对你的能力提升是毫无帮助的。 这 99% 里面，相当大一部分书是 「消遣性」 的，还有一些可能是跟你完全无关的领域。显然，这些书籍是不需要进行 「分析阅读」 的。
    - 第二层。 这一层次的书籍，你至少要做一次完整的“分析阅读”。经过一次分析阅读之后，你基本上就 「读通」了，知道这本书的主要精华。一旦读通，以后你就无需再去阅读。顶多是偶尔拿出来翻看个别重点，复习某些片段。
    - 第三层。 这一层次的书，非常非常少。它们的特点是：你无法通过一次完整的 「分析阅读」，就把它读通。甚至有可能你进行了 N 次分析阅读，也无法尽其究竟。
    - 第二层与第三层的差异。 第二层的书进行多次分析阅读， 每次的收获会逐渐变少。 因为自身的积累增多了， 理解力提升力， 而书的内容是固定的， 显然每次阅读， 收获降低了。 第三层的书会随着自身能力的提升， 每一次对该书进行分析阅读， 收获都是全新的。 甚至有可能后面的阅读， 收获会更多。 为啥会这样捏？因为这类书的作者，境界远远高于你本人。有可能在你一生的不同阶段都可以反复阅读同一本书，始终有收获。因为你始终达不到该书作者的境界。

  - 生命与心智的成长。 人类的心智有很奇怪的一点，主要是这一点划分了我们心智与身体的截然不同。我们的身体是有限制的，心智却没有限制。其中一个迹象是，在力量与技巧上，身体不能无限制地成长。人们到了30岁左右，身体状况就达到了巅峰，随着时间的变化，身体的状况只有越来越恶化，而我们的头脑却能无限地成长与发展下去。我们的心智不会因为到了某个年纪死就停止成长，只有当大脑失去活力，僵化了，才会失去了增加技巧与理解力的力量。

    这是人类最明显的特质，也是万物之灵与其他动物最主要不同之处。其他的动物似乎发展到某个层次之后，便不再有心智上的发展。但是人类独有的特质，却也潜藏着巨大的危险。心智就跟肌肉一样，如果不常运用就会萎缩。心智的萎缩就是在惩罚我们不经常动脑。这是个可怕的惩罚，因为证据显示，心智萎缩也可能要人的命。除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后

## 如何完善自己的知识结构

- 领域

  - 领域之间的包含关系。 
  - 领域之间的辅助关系

- 跨领域的知识分布

  - 广度和深度。 所谓广度， 是指你的知识结构中， 包含了多少领域。 所谓深度， 是指你对具体的每一个领域是否具有深入的了解和研究。
  - 深度的重要性。 只有广度而没有深度， 就会导致个人能力没有突出的亮点， 从而使自身缺乏竞争力。
  - 广度的重要性。 想要在某个领域做到足够深入， 必然要了解很多相关的辅助性领域的知识。
  - 深度和广度的平衡。 借鉴正态分布
  - 主攻方向的选择。若工作和自己的兴趣不一致时， 以自己的兴趣为主攻方向， 工作仅仅当做谋生手段。

- 领域内部的知识体系

  - 分支领域。

  - 主题

  - 知识树。 如果把某个领域想象成一棵树， 那么分支领域就如同树枝（树枝上还可以再有树枝）， 而主题如同树叶。 

  - 主题的选择。 主题通常是以疑问句的形式出现的。 大部分主题通常可以归为三类： WHAT 型， HOW 型， WHY 型。 

    - WHAT 型问题通常比较肤浅的， 表象的； 而 WHY 型问题通常是比较深刻的、 本质的；
    - 大部分 WHAT 型问题， 通常有标准答案； 而相当多的 WHY 型问题是没有标准答案的（HOW 型的问题介于两者之间）。

    所以， 如果想在某个领域做得标胶深入， 一定要多探寻 WHY 型的问题。 对这类问题的思考， **要避免 COPY 别人现成的答案， 要通过独立思考得出自己的答案**。 这类问题思考多了， 无形中就对该领域有更多更深入的了解。

- 知识点

  - 什么是知识点？ 通常表示某个**有价值**的信息。 关于知识和信息的关系， 可以参考 [DIKW 模型](https://en.wikipedia.org/wiki/DIKW_Pyramid)
  - 知识点的类型。 常见有如下几种：
    - 有些知识点是概念性的， 用来表示某种『定义』。 此类型是很重要的。 不论是哪个领域， 基本的概念和定义总是很关键的（犹如建筑的地基）。 如果你对这些东西的理解有误或有偏差， 就如同是『浮沙之上筑高台』。
    - 有些知识点是指导性的， 用来表示某种『方法』。方法论的重要性。
    - 有些知识点是陈述性的， 用来表示某种『事实』。远远不如前两种重要。
  - 如何应对「知识爆炸」？ 只记住核心的知识点， 舍弃边缘的知识点。[HOW](http://program-think.blogspot.com/2013/03/internet-resource-discovery-0.html)


## 学习技术的三部曲： WHAT、 HOW、 WHY

- WHAT。 What is it？ 这是最简单的层次。 在这个层次， 需要搞清楚某个知识点是什么， 有什么用处， 有什么特性， 有什么语法等。
- [HOW](https://program-think.blogspot.com/2009/01/2.html)。 How to do？ 在这个层次， 要搞清楚某个知识点其内部是如何运作的， 如何实现的等。 完成这个阶段之后， 你基本上就属于该技术领域最优秀的 20% 的人（根据二八原理， 80% 的人不会去思考 HOW 的问题）
- WHY。 一般来说， 只有想清楚了 HOW 之后， 才能继续去考虑 WHY。 所谓 WHY， 就是搞清楚某个知识点为什么设计成这样， 为什么不是另外的样子， 这样的设计有什么讲究等。

## 用提问来促进思维 —— 再谈 WHAT、 HOW、 WHY 三部曲

- 认知的过程

  从 [认知心理学](https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%BF%83%E7%90%86%E5%AD%B8) 的角度：我们对某个事物的认识，总是「由浅到深」。虽然同样是由浅到深，但每个人思考的深度却千差万别。不幸的是，大多数人在看待某个东西（事物、问题、现象）的时候，都仅仅停留在浅层次。

- WHAT HOW WHY 的步骤

  - WHAT
  - HOW
  - WHY
  - WHY 之后

## How to disagree

The web is turning writing into a conversation. Twenty years ago, writers wrote and readers read. The web lets readers respond, and increasingly they do—in comment threads, on forums, and in their own blog posts.

Many who respond to something disagree with it. That's to be expected. Agreeing tends to motivate people less than disagreeing. And when you agree there's less to say. You could expand on something the author said, but he has probably already explored the most interesting implications. When you disagree you're entering territory he may not have explored.

The result is there's a lot more disagreeing going on, especially measured by the word. That doesn't mean people are getting angrier. The structural change in the way we communicate is enough to account for it. But though it's not anger that's driving the increase in disagreement, there's a danger that the increase in disagreement will make people angrier. Particularly online, where it's easy to say things you'd never say face to face.

If we're all going to be disagreeing more, we should be careful to do it well. What does it mean to disagree well? Most readers can tell the difference between mere name-calling and a carefully reasoned refutation, but I think it would help to put names on the intermediate stages. So here's an attempt at a disagreement hierarchy:

- DH0 Name-calling

  This is the lowest form of disagreement, and probably also the most common. We've all seen comments like this:

  > u r a fag!!!!!!!!!!

  But it's important to realize that more articulate name-calling has just as little weight. A comment like

  > The author is a self-important dilettante.

  is really nothing more than a pretentious version of "u r a fag."

- DH1 Ad Hominem

  An ad hominem attack is not quite as weak as mere name-calling. It might actually carry some weight. For example, if a senator wrote an article saying senators' salaries should be increased, one could respond:

  > Of course he would say that. He's a senator.

  This wouldn't refute the author's argument, but it may at least be relevant to the case. It's still a very weak form of disagreement, though. If there's something wrong with the senator's argument, you should say what it is; and if there isn't, what difference does it make that he's a senator?

  Saying that an author lacks the authority to write about a topic is a variant of ad hominem—and a particularly useless sort, because good ideas often come from outsiders. The question is whether the author is correct or not. If his lack of authority caused him to make mistakes, point those out. And if it didn't, it's not a problem.

- DH2 Responding to Tone

  The next level up we start to see responses to the writing, rather than the writer. The lowest form of these is to disagree with the author's tone. E.g.

  > I can't believe the author dismisses intelligent design in such a cavalier fashion.

  Though better than attacking the author, this is still a weak form of disagreement. It matters much more whether the author is wrong or right than what his tone is. Especially since tone is so hard to judge. Someone who has a chip on their shoulder about some topic might be offended by a tone that to other readers seemed neutral.

  So if the worst thing you can say about something is to criticize its tone, you're not saying much. Is the author flippant, but correct? Better that than grave and wrong. And if the author is incorrect somewhere, say where.

- DH3 Contradiction

  In this stage we finally get responses to what was said, rather than how or by whom. The lowest form of response to an argument is simply to state the opposing case, with little or no supporting evidence.

  This is often combined with DH2 statements, as in:

  > I can't believe the author dismisses intelligent design in such a cavalier fashion. Intelligent design is a legitimate scientific theory.

  Contradiction can sometimes have some weight. Sometimes merely seeing the opposing case stated explicitly is enough to see that it's right. But usually evidence will help.

- DH4 Counterargument

  At level 4 we reach the first form of convincing disagreement: counterargument. Forms up to this point can usually be ignored as proving nothing. Counterargument might prove something. The problem is, it's hard to say exactly what.

  Counterargument is contradiction plus reasoning and/or evidence. When aimed squarely at the original argument, it can be convincing. But unfortunately it's common for counterarguments to be aimed at something slightly different. More often than not, two people arguing passionately about something are actually arguing about two different things. Sometimes they even agree with one another, but are so caught up in their squabble they don't realize it.

  There could be a legitimate reason for arguing against something slightly different from what the original author said: when you feel they missed the heart of the matter. But when you do that, you should say explicitly you're doing it.

- DH5 Refutation

  The most convincing form of disagreement is refutation. It's also the rarest, because it's the most work. Indeed, the disagreement hierarchy forms a kind of pyramid, in the sense that the higher you go the fewer instances you find.

  To refute someone you probably have to quote them. You have to find a "smoking gun," a passage in whatever you disagree with that you feel is mistaken, and then explain why it's mistaken. If you can't find an actual quote to disagree with, you may be arguing with a straw man.

  While refutation generally entails quoting, quoting doesn't necessarily imply refutation. Some writers quote parts of things they disagree with to give the appearance of legitimate refutation, then follow with a response as low as DH3 or even DH0.

- Refuting the Central Point

  The force of a refutation depends on what you refute. The most powerful form of disagreement is to refute someone's central point.

  Even as high as DH5 we still sometimes see deliberate dishonesty, as when someone picks out minor points of an argument and refutes those. Sometimes the spirit in which this is done makes it more of a sophisticated form of ad hominem than actual refutation. For example, correcting someone's grammar, or harping on minor mistakes in names or numbers. Unless the opposing argument actually depends on such things, the only purpose of correcting them is to discredit one's opponent.

  Truly refuting something requires one to refute its central point, or at least one of them. And that means one has to commit explicitly to what the central point is. So a truly effective refutation would look like:

  > The author's main point seems to be x. As he says:
  >
  > ​	<quotation>
  >
  > But this is wrong for the following reasons...

  The quotation you point out as mistaken need not be the actual statement of the author's main point. It's enough to refute something it depends upon.

- What It Means

  Now we have a way of classifying forms of disagreement. What good is it? One thing the disagreement hierarchy *doesn't* give us is a way of picking a winner. DH levels merely describe the form of a statement, not whether it's correct. A DH6 response could still be completely mistaken.

  But while DH levels don't set a lower bound on the convincingness of a reply, they do set an upper bound. A DH6 response might be unconvincing, but a DH2 or lower response is always unconvincing.

  The most obvious advantage of classifying the forms of disagreement is that it will help people to evaluate what they read. In particular, it will help them to see through intellectually dishonest arguments. An eloquent speaker or writer can give the impression of vanquishing an opponent merely by using forceful words. In fact that is probably the defining quality of a demagogue. By giving names to the different forms of disagreement, we give critical readers a pin for popping such balloons.

  Such labels may help writers too. Most intellectual dishonesty is unintentional. Someone arguing against the tone of something he disagrees with may believe he's really saying something. Zooming out and seeing his current position on the disagreement hierarchy may inspire him to try moving up to counterargument or refutation.

  But the greatest benefit of disagreeing well is not just that it will make conversations better, but that it will make the people who have them happier. If you study conversations, you find there is a lot more meanness down in DH1 than up in DH6. You don't have to be mean when you have a real point to make. In fact, you don't want to. If you have something real to say, being mean just gets in the way.

  If moving up the disagreement hierarchy makes people less mean, that will make most of them happier. Most people don't really enjoy being mean; they do it because they can't help it.

## 使用 GitHub 的几种方式 —— 兼谈安全性和隐匿性的经验

- 本文的 Prerequisite
  - 版本管理系统的基本概念
  - Git 的基本概念
  - GitHub 的基本使用
  - Git 客户端的基本使用
  - Linux 或 Mac OS 命令行的基本使用
  - 常见翻墙工具的基本使用
  - TOR 的使用

- 使用 GitHub 的两种方式
  - B/S 方式 —— 基于浏览器。 最基本的使用方式。 只要注册了 GitHub 账户， 就知道如何用浏览器访问它。 也称为 「Web 方式」
  - C/S 方式 —— 基于客户端软件。 通过 Git 客户端软件来操作 GitHub 上的代码仓库。 这种方式称为 「客户端软件方式」。
  - 两种方式的对比
    - B/S 方式最大的好处是， 无须安装额外的软件； 另一个好处是 GitHub 几乎所有的功能， 都可以在浏览器界面上搞定， 但也存在一些缺点：
      - 安全性。 
      - 易用性。 有些大批量操作， 在 Web 界面上不太方便。
    - C/S 方式正好弥补了 「Web 方式」 的这几个缺点。

- Client方式支持哪些协议
  - Git 协议。 Git 专有的协议， 除了用于 Git 客户端与服务端之间的通信， 其他场合用不到它。 注意， Git 协议本身是明文的（无加密）
  - HTTP/HTTPS 协议。
  - SSH 协议。 Secure Shell 的缩写， 是加密的

- 上述几种 Client 协议的优缺点对比
  - Git 协议
    - 明文传输的协议， 很容收到「旁路嗅探」(sniffer) —— 导致你丧失数据的 「保密性」
    - 明文传输的协议， 很容易在传输过程中被修改（恶意篡改） —— 导致你丧失数据的 「完整性」
  - HTTP 协议。 明文传输的协议， 同上
  - HTTPS 协议。 加密协议
    - 访客身份也可以使用。 即使你没有注册 GitHub 的用户， 也可以通过 HTTPS 协议克隆某个项目
    - 更容易穿透防火墙。 很多公司内网的防火墙会屏蔽大部分端口， 但是 HTTPS 所用的 443 端口通常是没有屏蔽的。
  - SSH 协议。 加密协议。 
    - 提供了额外的认证方式。 对于 SHH 协议， GitHib 支持 「公钥方式」(public key) 的认证， 当设置好这种认证方式， 就不再需要用你的账号和密码， 也可以操作你的代码仓库。 这样做的好处是， 万一你的系统被入侵， 顶多泄露你的 key， 但不会泄露你的 GitHub 的账号和密码。 而且 key 被泄露之后， 可以去你的账户的配置界面， 把已经泄露的 key 撤销掉。 撤销以后， 入侵者就算拿到这个 key， 也无法再操作你的代码仓库了。
    - 支持「项目级」颗粒度的控制。 通俗地说就是： 你可以为不同的长裤配置不同的 SSH key， 这样， 一个 key 只能操作一个代码库， 一旦 key 泄露， 损失就小得多了

- 如何用 SSH 方式操作 GitHub 项目

  - 安装 openssh。 Linux 发行版中一般已内置。

  - 创建「公钥/私钥对」。 `ssh-keygen -t rsa -b 4096 -f 文件路径 -C 邮箱地址`

    - `-t rsa`： 表示加密算法的类型是 RSA
    - `-b 4096`： 表示密钥是 4096 位/比特。 注意，不同加密算法的位数，没有可比性。对于 RSA 加密算法，如果你没有指定 -b 参数，则默认值是 1024；以目前的破解水平，2048 应该够安全了。为了保险起见， 这里创建 4096 比特的密钥

  - 密钥文件的存放。上述命令中的 「文件路径」 表示私钥文件存放的路径。 ssh-keygen 会自动在这个路径末尾附加 .pub 作为公钥文件的路径。 如果要创建不止一个 「公钥私钥对」， 要使用具有一定可读性的文件名， 以免自己搞混了（[参考](https://martin.kleppmann.com/2013/05/24/improving-security-of-ssh-private-keys.html)），**私钥文件非常重要， 不要泄露给外人**。

  - 在 GitHub 上指派密钥。 GitHub 支持两种方式的 SSH key， 分别是用户级和项目级。

    - 用户级。 使用该 key 可以操作所有项目的代码仓库。 设置方法为： 「进入 User Profile —> SSH keys —> New SSH key —> 把**公钥文件**的内容原封不动的 copy paste 到页面中的多行文本框里面」 
    - 项目级。 只能操作所属项目的代码仓库。 设置方法为： 「进入该项目的 Setting 页面 —> Deploy keys —> Add deploy key —> 把**公钥文件**的内容原封不动的 copy paste 到页面中的多行文本框里面」

  - 测试 SSH 登录。 运行命令 `sh -i 公钥文件路径 -T git@github.com` ， 若出现提示， 输入 `yes` 后， 若出现 「You've successfully authenticated」， 则表示该 ssh key 已经通过登录认证。

  - 修改 SSH 的配置文件。 SSH 配置文件的路径是 *~/.ssh/config*， 如果系统中没有这个文件， 就创建一个。 参考下面的示例进行修改。

    ```nginx
    Host 别名
      HostName                  ssh.github.com
      Port                      443
      User                      git
      PreferredAuthentications  publickey
      IdentityFile              私钥文件路径
    ```

    所谓的「别名」， 用来替换 URL 中的主机名。 之后如果要 clone 某个项目， 就需要使用如下命令： `git clone ssh://别名/username/projectname`

  - 后续操作。 前面几个步骤都搞定之后， 就可以通过 ssh 协议把某个项目 clone 到本地， 修改完， 再 push 到 GitHub 上。 整个过程都是通过 「强加密的」 SSH 协议完成。

- 使用代理的必要性/重要性

  - 为啥要使用代理
    - 不让 GitHub 的服务器看到你的公网 IP。 直接使用公网 IP， 存在如下风险
      - GitHub 有一个 「Session」 功能， 可以显示你最近几次登录时使用的 「访问者 IP」， 万一某天你的帐号被入侵了，那么入侵者就可以利用该功能，看你的 「访问者IP」，如果你没有走代理，那么你的“访问者IP”也就是本人的「公网IP」。
      - 即使 GitHub 公司的管理层非常有骨气，但是不保证该公司所有的员工也都是如此。万一某个服务器管理员被第三方收买了，或许会把某些用户资料卖给第三方。（如果你没有走代理）然后第三方的人就可以通过服务器上记录的 「访问者IP」来定位你。
      - 即使 GitHub 公司的全体员工都非常有骨气，还有一个风险是：黑客有可能会入侵 GitHub 的服务器。这可不是俺耸人听闻。即使牛B如 Google，依然在2011年遭遇了天朝御用骇客的【深度渗透】。那次渗透的程度之深，据说入侵者已经接触到 Gmail 的核心服务器，并拿到了几个敏感人士（民运人士）的邮件内容。这次事件后来被称为 「极光行动」，此事直接导致了 Google 高层震怒并退出大陆市场。
  - 为啥要使用基于 TOR 的双重代理。 

- 针对不同的 Git 使用方式， 如何配置代理

  - B/S 方式。 只需要让浏览器通过 TOR 的线路访问 GitHub 的页面就可以了。 [Reference](https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html)

  - C/S 方式下的 HTTPS 协议。 需要修改 Git 的配置参数， 让 Git 知道 TOR 代理的 IP 和端口， 命令如下 `git config --global http.proxy SOCKS5h://地址:端口号` 。 说明如下：

    - 如果 TOR 客户端运行在 **本机**， 那么上述命令中的 「地址」 就替换为： **127.0.0.1**， 否则就替换为 **运行 TOR 客户端的主机的 IP 地址**
    - 如果 TOR 客户端用的是 **TOR Browser**， 端口号必须是 **9150**， 如果用的 TOR 的其他软件包， 则端口号使用 **9050**

  - C/S 方式下的 SSH 协议。要让 SSH 通过 TOR 的代理， 稍微麻烦一点， 因为 TOR 默认提供的是 SOCKS 代理， 而 OpenSSH 客户端默认又不支持 SOCKS 代理。 因此需要依靠第三方工具来实现 **SSH through SOCKS**。 为了搞定 「SSH through SOCKS」， 此处使用 nc（netcat）。 由于由于这个 netcat 名气很大，主流 Linux 发行版的软件仓库中都有它。你只需要用发行版自带的软件包管理器，把 nc 装上。装好 nc 之后，可以用如下命令测试 「SSH through TOR SOCKS」 是否成功。`ssh -o "ProxyCommand=nc -X 5 -x 地址:端口号 %h %p" -T ssh.github.com`。 说明如下：

    - 如果 TOR 客户端运行在 **本机**， 那么上述命令中的 「地址」 就替换为： **127.0.0.1**， 否则就替换为 **运行 TOR 客户端的主机的 IP 地址**
    - 如果 TOR 客户端用的是 **TOR Browser**， 端口号必须是 **9150**， 如果用的 TOR 的其他软件包， 则端口号使用 **9050**

    上述测试命令如果最终显示 *Permession denied* 就说明已经通过 SOCKS 代理链接到 GitHub 了， 如果没有显示这个信息， 而是显示了其他信息， 再用如下命令重新试一次。 `ssh -o "ProxyCommand=nc -X 5 -x 地址:端口号 %h %p" -Tv ssh.github.com`。 *-v* 的目的是打印详细的诊断信息。 然后根据诊断信息， 判断出错的原因。 搞定之后， 为了方便起见， 同样可以把 SSH 的这个 ProxyCommand 命令行选项加入到 SSH 的配置文件。如此一来，以后每次你要连接 GitHub 的服务器，都会自动走 TOR 提供的 SOCKS 代理。  参考如下示例：

    ```nginx
    Host 别名
      HostName                  ssh.github.com
      Port                      443
      User                      git
      PreferredAuthentications  publickey
      IdentityFile              私钥文件路径
      ProxyCommand              /usr/bin/nc -X 5 -x 地址:端口号 %h %p
    ```

## 如何成为优秀开发人员

### 怎样算是优秀的

应具有以下素质：

- 快速的开发效率
- 良好的程序设计
- 良好的代码质量
- 善于 Debug
- 能够解决技术难题

### 关于兴趣

> 兴趣是最好的老师 —— 爱因斯坦

### 关于自学的能力

- 自学的重要性
  - IT 行业知识的更新速度快
  - 工作中终归会需要用到某个新技术是以前没有学过的
- 自学的主动性
  - 抗拒自学者。 这类人不愿意自学（部分是由于懒惰， 另一些是由于抵触新事物）。
  - 被动自学者。 这类人平时没事不会想到去自学新东西， 只有在工作中需要学 XX 技术， 才会勉为其难地去学。
  - 需求驱动型自学者。 这类人自学的动机和方向是基于需求驱动， 比如工作中要用到 XX 框架、 XX 库、 XX 软件， 然后就利用业余时间找资料去看。
  - 计划型自学者。 这类人自学的动机和方向是基于自己规划。 定期看看自己的知识结构有什么缺陷， 将来自己想朝什么方向发展， 最近哪个新东西将来会用得上等， 然后给自己定一个学习计划
- 自学的常用招数
  - 搜索引擎
  - 百科类网站。 只能走基本的了解， 当需要深入了解时， 此类网站无法满足要求。
  - 订阅 BBS， Mailing List， Blog。订阅的好处， 是可以让信息自己跑到你的面前来。 
  - 看书。 当要系统的掌握某个比较复杂的技术时， 首选找一本针对的好书。 为了能找到好书， 需要利用搜索引擎或者专门的网站（如豆瓣、 亚马逊等）来识别好书与坏书。 

### 设定个人发展目标和技术

个人发展目标就是和个人的职业发展有关的目标， 包括知识、 技能、 工作岗位等都可以被设定为个人发展目标。可以把个人发展目标分为『长、  中、 短』 三种 类型。不管哪类目标， 都要把**目标设置得难易适中**

- 短期目标。 时间跨度大约在几个星期到一个季度之间。 短期目标要定得比较具体， 便于自己评估目标是否达成。 如「在本月读完《Thinging in C++》」、 「在本月熟悉 Spring 框架」、 「在这2个月用 Flex 写一个五子棋游戏」
- 中期目标。 时间跨度大约是几个季度到1-2年。 中期目标比短期目标抽象， 且必须是短期目标的有机结合。 比如有个短期目标是「本周看完《Dive into Python》」， 那么对应的中期目标可以是 「1年内成为熟练的 Python 程序员」。
- 长期目标。 长期目标同样也必须和中期目标沾边， 它的层次当然更高， 时间跨度大约在 5 年以上。 而且长期目标一般不会关系到具体的 XX 语言、 XX 平台等， 倒是进场和职业岗位有一定的关联， 如「5-7年内称为技术总监」， 「5年内称为公司产品的架构师」等。

设定好3个阶段的目标， 就形成了个人发展计划。 既然是计划， 就得在每一个阶段结束时自己总结一下， 评估一下该目标的完成情况好不好， 有什么收获、 有什么经验教训。 必要的话还需要对尚未开始的后续目标进行一个调整。 定义回顾还有一个好处， 就是能获得一种满足感， 从而有利于坚持完整个计划。

### 做正确的事

一般来说， 优秀的开发人员往往具有较高的效率， 效率主要是指『做正确的事』和『正确地做事』。 并且『做正确的事』比『正确地做事』更加重要。 先看一些反面教材， 大部分人（80%以上）具有如下**不好**的工作习惯：

- 先做自己喜欢的事情， 再做自己不喜欢的事
- 先做紧急的事情， 再做不紧急的事情
- 先做容易做的事情， 再做不容易做的事情
- 先做自己了解、 熟悉的事情， 再做自己不了解、 不熟悉的事情
- 先做有趣的事情， 再做枯燥的事情
- 先做易于告一段落的事情， 再做不易于告一段落事情
- 先做自己熟悉的人托付的事情， 再做自己不熟悉的人托福的事情

『做正确的事』的关键在于评估你准备做的每件事情的权重。 权重来源于这件事情对于达成你的目标是否有帮助， 帮助有多大。 帮助越大， 则权重越大。 然后， 每天醒来， 都要把当天准备做的事情根据权重排好优先级， 然后严格按照优先级顺序执行。

如果工作中偶尔碰上看起来紧急的突发事情，也不要轻易改变原先安排的计划表，而要先冷静评估一下这个紧急的事情的权重。只有属于紧急且权重高（重要）的突发事件，你才可以调整计划，把这件突发事情加入其中。关于重要性和紧急性的平衡与处理，在[杜拉克](http://zh.wikipedia.org/wiki/%E5%BD%BC%E5%BE%97%C2%B7%E5%BE%B7%E9%B2%81%E5%85%8B)的名著“卓有成效的管理者”中有详细的介绍

### 正确地做事

> 程序员的三大美德： 懒惰、 急躁、 傲慢 —— Larry Wall, Perl 创始人。

懒惰应为干尽量少的活， 但是依然保质保量地完成工作。

## 如何选择 IT 技术书籍

- 看网上评论
  - 英文书籍： 亚马逊， 一般大于等于四星的评级都不差
  - 中文书籍： 豆瓣网， 一般大于等于四星的评级都不差
- 看作者。 如果作者是该领域的技术大牛或者知名评论家， 该书的质量一般不会太差。 用这招的前提是需要对这本书所在的领域有一定的了解， 知道哪些人属于该领域的大牛
- 看出版信息。 主要看出版社、 出版时间。 好的出版社出的书， 总体水平还过得去， 不至于太烂， 排版印刷错误也较少。 出版时间的重要性得看具体的领域。 比如某些领域（算法、 软件工程等）的书， 对于时间不敏感。 即使年代久远也没有过时（比如人月神话）。 而另一些领域（涉及具体的语言、 软件、 操作系统）则需要与时俱进， 3-5年之前出版的书可能就已经过时了。 如果是纸版书， 还可以看看再版次数和印数。 这两个指标一般和销量成正比。 不过也不排除少数阳春白雪的好书， 销量很低。 因此这两个指标仅供参考。
- 看目录。 好书的目录一般层次分明、 条理清晰。 烂书反之。 看目录可以在最短时间内大致了解该书的深浅以及内容的分布（看每一章占了多少页）， 从而判断这本书是否适合自己。
- 抽查几页。 挑书中某个小节看一下。 看看作者的文笔是否流畅、 生动。 如果是翻译的数， 还要注意以下翻译的水平如何。 翻译的书的质量同时取决于作者和译者的水平， 任何一个不行， 整本书就好不到哪里去。

## 为什么选择使用 Go 语言

- Go 的特性：
  - 静态语言
  - 天生并发
  - 内置 GC
  - 安全性高
  - 语法简单
  - 交叉编译
  - 编译快速
  - 三快： 运行快、 开发快和部署快
- 设计 Go 语言的目的
  - 为了解决当时 Google 开发遇到的以下问题
    - 大量的 C++ 代码， 同时又引入了 Java 和 Python
    - 成千上万的工程师
    - 数以万计行代码
    - 分布式的编译系统
    - 数百万的服务器
  - 主要有以下几个方面的通电：
    - 编译慢
    - 失控的依赖
    - 每个工程师只是用了一个语言里面的一部分
    - 程序难以维护 (可读性差、 文档不清晰等)
    - 更新的花费越来越长
    - 交叉编译困难
  - 目标是为了消除各种缓慢和笨重、 改进各种低效和扩展性。 Go 是由那些开发大型系统的人设计的， 同时也是为了这些人服务的； 它是为了解决工程上的问题， 不是为了研究语言设计； 同时它还是为了让我们的程序变得更舒适和方便。
- 应用
  - 服务器编程。 如处理日志、 数据打包、 虚拟机处理、 文件系统等
  - 分布式系统。 数据库代理器等， 如 Etcd
  - 网络编程。 应用最广， 包括 Web 应用、 API 应用、 下载应用， 而且 Go 内置的 net/http 包基本上把平常用到的网络功能都实现了
  - 数据库。 Groupcache、 Couchbase 的部分组件、 Tidb、 Cockroachdb、 Influxdb 等
  - 云平台。
- 为什么选择使用 Go 语言？
  - 学习曲线： 平缓
  - 效率： 接近 C 和 PHP 的运行效率
  - 出身名门、 血统纯正
  - 自由高效： 组合的思想、 无侵入式的接口。 Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程以及函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。
  - 强大的标准库。 包括互联网应用、 系统编程和网络编程。
  - 部署方便： 二进制文件、 Copy 部署。
  - 简单的并发。 包含了降低心智的并发和简易的数据同步， 这可能是 Go 最大的特色。 之所以写正确的并发、 容错和可扩展的程序如此之难， 是因为我们用了错误的工具和错误的抽象， Go 可以说这一块做的相当简单。
  - 稳定性。 Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。
- 缺点
  - Go 的 Import 包不支持版本， 有时候升级容易导致项目不可运行， 所以需要自己控制相应的版本信息（从Go 1.5开始Go对此就有重视了并支持Vendor）。
  - Go的goroutine一旦启动后，不同的goroutine之间切换不是受程序控制，runtime调度的时候需要严谨的逻辑，不然goroutine休眠，过一段时间逻辑结束了却突然冒出来又执行了，这会导致逻辑出错等情况。这个目前无解，应该属于调度器的优化。
  - GC延迟有点大，我开发的日志系统伤过一次，同时在并发很大的情况下，处理很大的日志，GC没有那么快，内存回收不给力，后来经过Profile程序改进之后得到了改善。目前来看，GC已经优化的非常好了。
  - pkg下面的图片处理库很多bug，还是使用成熟产品好，调用这些成熟库imagemagick的接口比较靠谱。


## 【排序算法】 —— 《Java 数据结构与算法》读书笔记

不变性：在很多算法中，有些条件在算法执行时是不变的，这些条件被称为不变性。如冒泡中，out右边的所有数据项为有序，在算法的整个运行过程中这个条件始终为真。(一开始，out右边数为0)

**初级**

冒泡排序。 执行非常慢， 概念上最简单

```java
int out,in;
for(out=size-1;out>1;out--) { // outer loop(backward)
     for (in = 0; in < out; in++) { // inter loop(forward)
       if (a[in] > a[in + 1]) { // out of order?
           swap(in, in + 1); // swap them
        }
   }
}
```

在内部循环中就是一个冒泡，从头到尾，比较左右两个，如果逆序就交换位置，最大的那一项会一直被交换，直到排最后。1,2比较，(交换)，2,3比较，3和4比较，4和5比较。这里的数字指的是位置，假如2是5个数据中最大的一个，1和2比较，不变，2和3比较，二者交换位置，最大值到了3位置，3和4比较，最大值到了4位置，再到5位置。冒泡，冒上来。
在外层循环中，是给内层循环设置数据比较的最后一项，因为下标大于out的数据项都已经排好序了，是最大的放后面，不需要再比较了。变量out在每完成一个内层循环后，就左移一位。

冒泡的效率: 比较的次数，(N-1) + (N-2) + (N-3) + ...+ 1= N*(N-1)/2,交换的次数取平均NxN/4,这个算法0(N^2)

选择排序。我觉得名字起得不好，体现不出这个算法的思想(主要是冒泡算法太形象了)。
思想：比较所有的数据项，取出最小值，放左边。比较剩下的数据，取最小，放最左。。。。
内层循环中，每一个in的新位置，数据项a[in]和a[min]比较，如果a[in]更小，则min被赋值为in的值，这里只是下标，没交换。到一次内层循环结束，再交换数据项。这样，最小数据项就会一直被放在左边。
比较的次数和冒泡是一样的，但是交换的次数小。因为交换数据需要在内存中移动，时间上要多(java语言中，影响不大，只是改变引用位置而已)

```java
int out, in, min;
for (out = 0; out < nElems - 1; out ++) { // outer loop
  min = out; // minimum
  for (in = out + 1; in < nElems; in ++) { // inner loop
    if (a[in] < a[min]) { // if min greater
      min = in; // we have a new min
    }
    swap(out, min); // swap them
  }
}
```

插入排序。 

思想：假设左边部分已经排序好了，从某个位置(比如10)开始无序，将10赋值给一临时值，然后和前面的数据比较，如果9位置比10大，就9右移一位，继续和8比较。。。直到到数据的最左边或找到比10位置数据小的某数据，放在它的右边，10位置的数据就排好了。
在大多数情况下，插入算法仍然需要0(N^2)的时间，但比冒泡快一倍，比选择排序也还要快一点。经常被用在较复杂的排序算法的最后阶段，例如快速排序。

```java
int in,out; 
for(out = 1;out < nElems; out++){ //out is dividing line 
    long temp = a[out]; //remove marked item 
    in = out; //start shifts at out 
    while(in > 0 && a[in - 1] >= temp){ //until one is smaller, 
        a[in] = a[in -1] //shift item right 
        --in; 
    } 
    a[in] = temp; //insert marked item 
}
```

外层的for循环中，out变量从1开始，向右移动,它标记了未排序部分的最左端的数据。
而在内层while循环中，in变量从out变量开始，向左移动，知道temp变量小于in所指的数组数据项，或者它已经不能再往左移动为止。while循环的每一次都向右移动了一个排序的数据项。

在每次结束时，在将temp位置的项插入后，比outer变量下标号小的数据项都是局部有序的。
比较次数，1+2+3+...+(N-1) = Nx(N-1)/2，而因为每一次排序发现插入点之前，平均只有全体数据项的一半真的进行了比较，所以是N*(N-1)/2 /2
复制的次数大致等于比较的次数。复制和交换的时间耗费不同。相对于随机数据，这个算法比冒泡快一倍，比选择排序略快。
对于已经有序或基本有序的数据来说，插入排序要好得多。对于逆序排列的数据，每次比较和移动都会执行，所以插入排序不比冒泡排序快。

**中级**

归并排序。只要O(N *logN)，而冒泡排序，选择排序，插入排序都要用O(N *N);.
归并排序的思想是：将一个数组分成两半，然后分别排序，然后将数组的两半合并，合并的时候需要比较大小(合并的时候还要考虑两小数组还有没有数据，即有可能一边有，另一边没有)。至于如何排序1/2半的数组，当然是再分成两个1/4数组，再排序。。。直到分割的小数组只有1个数据项，不用排序了。这是用到递归的思想
归并排序的缺点，需要在存储器中有另一个大小等于被排序的数据项数目的空间，用来复制分割出来的小数组。
归并算法的效率由来：需要复制log<sub>2</sub><sup>N</sup>层(分子数组)，每一个层都是N个数据，所以是NxlogN.

```java
int[] workSpace = new int[source.length];
recMergerSort(source,workSpace,0,length-1);

private static void recMergeSort(int[] source, int[] workSpace, int lowerBound, int upperBound) {
    if (lowerBound == upperBound) {
        return; // if range is 1,no use sorting
    } else {
        int mid = (lowerBound + upperBound) / 2; // find midpoint
        recMergeSort(source, workSpace, lowerBound, mid); // sort low half
        recMergeSort(source, workSpace, mid + 1, upperBound); // sort high half
        merge(source, workSpace, lowerBound, mid + 1, upperBound); // merge them
    }
}

private static void merge(int[] source,int[] workPlace, int lowPtr, int highPtr, int upperBound) {
    int j = 0;   // workspace index
    int lowerBound = lowPtr;
    int mid = highPtr - 1;
    int n = upperBound - lowerBound + 1;   // size of items
    while (lowPtr <= mid && highPtr <= upperBound){
       if (source[lowPtr] < source[highPtr]){
            workPlace[j++] = source[lowPtr++];
       } else {
            workPlace[j++] = source[highPtr++]
       }
   }
   while (lowPtr <= mid){
       workPlace[j++] = source[lowPtr++];
   }
   while (highPtr <= upperBound){
       workPlace[j++] = source[highPtr++];
   }
   for (j = 0;j < n; j++) {
       source[lowerBound + j] = workPlace[j];
   }
}
```

**高级**： 希尔排序， 快速排序。 希尔排序大约需要O(Nx(logN)^2)时间，快速排序需要O(N*logN)时间。而这两种算法都不需要大量的辅助存储空间，不同于归并算法。快速排序是所有通用排序算法中最快的一个排序算法。

希尔排序基于插入排序，但增加了一个新的特性，大大地提高了插入排序的执行效率。(希尔是个人名。。。)
改进的地方：插入算法中，如果一个数据比较小而居于最右边，那么它需要一个一个地移动所有中间的数据项，效率比较低。
希尔排序通过加入插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能大跨度地移动。当这些数据项排过一趟序后，减小数据项的间隔。再进行排序，依次进行下去。间隔被称为增量，用h表示.进行过几次增量排序后，所有的元素离它再最终有序序列中的位置相差不大，数组达到"基本有序",这时再来插入排序，移动量非常小。当h值很大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这是非常有效率的。当h减少时，每一趟排序需要移动的元素的个数增多，但是此时数据项已经接近于它们排序后最终的位置，这对于插入排序可以更有效率。其中，h = h x 3 +1, h = (h -1) / 3,是经验值。

```java
class ArraySh {
    private long[] theArray;
    private int nElems;

    public ArraySh(int max) {
        theArray = new long[max];
        nElems = 0;
    }

    public void insert(long value) {
        theArray[nElems] = value;
        nElems++;
    }

    public void shellSort() {
        int inner, outer;
        long temp;
        int h = 1;
        while (h <= nElems / 3) {
            h = h * 3 + 1;
        }
        while (h > 0) {
            for (outer = h; outer < nElems; outer++) {
                temp = theArray[outer];
                inner = outer;
                while (inner > h - 1 && theArray[inner - h] >= temp) {
                    theArray[inner] = theArray[inner - h];
                    inner -= h;
                }
                theArray[inner] = temp;
            }
            h = (h - 1) / 3;
        }
    }
}
```

快速排序。

划分是快速排序的根本机制，但是划分本身也是一个有用的操作，这里单讲划分的算法。
划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，使所有关键字小于特定值的数据项在另一组。

划分算法由两个指针开始工作，两个指针分别指向数组的两头。在左边的指针，leftPtr，向右移动，而在右边的指针，rightPtr，向左移动。
实际上，leftPtr初始化时是在第一个数据项的左边一位(-1)，rightPtr是在最后一个数据项的右边一位(size)，这是因为在工作之前，它们都要分别的加一和减一。
停止和交换：当leftPtr遇到比枢纽(特定值，划分值)小的数据项时，它继续右移，因为这个数据项的位置已经处在数组的正确一边了。但是，当遇到比枢纽大的数据项时，它就停下来。类似的，当rightPtr遇到小于枢纽的数据项时，它也停下来。两个内层的while循环，控制这个扫面过程，当两个都停下来时，要么指针到头要么遇到错误的数据(大小比较不对)，做交换(更换位置，正确排列了)。
当两个指针最终相遇的时候，划分过程结束，并且推出这个外层的while循环。

```java
class ArrayPar {
    private long[] theArray;
    private int nElems;

    public ArrayPar(int max) {
        theArray = new long[max];
        nElems = 0;
    }

    public void insert(long value){ 
        theArray[nElems] = value;
        nElems++; 
    }

    public int partitionIt(int left,int right,long pivot){ 
        int leftPtr = left - 1; 
        int rightPtr = right + 1; 
        while(true) { //这里需要检查边界，povit是外界设定，对效率影响很大，在快速排序中有更巧妙的设定方法 
            while(leftPtr < right && theArray[++leftPtr] < povit); //find bigger item 
            while(rightPtr > left && theArray[--rightPtr] > povit); //find smaller item 
            if(leftPtr >= rightPtr) { //if pointers cross, partition done 
                break;
            } else { 
                swap(leftPtr,rightPtr);
            }
            return leftPtr;
        }
    }
}
```

这个while循环中的代码相当精巧。举例来说，想要从内部循环条件中除去加1操作符，并且用这个加1操作符代替空操作指令语句(空操作指令指只包括一个分号的语句，它表示不做任何操作)。
可以把如下代码： 

```java
while(leftPtr < right && theArray[++leftPtr] < pivot);
```

改为

```java
while(leftPtr < right && theArray[leftPtr] < pivot) {
	++leftPtr
};
```

这些改变使指针的初始值分别设为left,right，比设为left-1,right+1要更为清晰。 但是，这些改变导致只有在满足条件的情况下指针才会加1.而指针在任何情况下都必须移动，所以空操作指令是最有效的解决办法。

快速排序是当下最流行的排序算法，时间复杂度为O(N*logN)。虽然不觉得这种行为好，但有的公司喜欢笔试时让人手写快排(一些开发者如是说)。
原理是：把一个数组划分为两个子数组，这里用到划分算法，左子数组的数据项都小于右子数组的数据项，然后递归地调用自身为每个子数组进行快速排序来实现，最后使用插入排序。在这个算法中划分的关键值(枢纽)的选择非常重要。

最初思想，选用数组最右边的值为pivot,进行一次划分，划分的结果就是left->mid-1, mid->right-1, right(这个位置的值是pivot)，三部分，然后交换mid和right的值(划分算法的leftPtr在停止时会停在mid位置)，这样pivot就到中间，而小于pivot的值全在左边，大于的值全在右边，数组的排序不受影响。
下面的排序从left到pivot-1,pivot+到right。中间项不参与划分。

```java
class ArrayIns {
  private long[] theArray;
  private int nElems; // elements number, or size
  public ArrayIns(int max) {
    the Array = new long[max];
    nElems = 0;
  }
  public void insert(long value) {
    theArray[nElems] = value;
    nElems ++;
  }
  public void quickSort() {
    recQuickSort(0, nElems - 1);
  }
  private void recQuickSort(int left, int right) {
    if(right - left <= 0) { // if size <= 1, already sorted
      return;
    } else {
      long pivot = theArray[right]; // rightmost item
      int partition = partitionIt(left, right, pivot);
      recQuickSort(left, partition - 1); // sort left side
      recQuickSort(partition + 1, right); // sort right side
    }
  } // end recQuickSort()
  private int partitionIt(int left, int right, long pivot) {
    int leftPtr = left - 1;
    int rightPtr = right; // 这里设定最右为 pivot， 所有从 right-1 开始划分， 下面代码会 -1
    while(true) {
      while(theArray[++ leftPtr] < pivot);
      while(rightPtr > 0 && theArray[--rightPtr] > pivot);
      if(leftPtr >= rightPtr) {
        break;
      } else {
        swap(leftPtr, rightPtr);
      }
    } // end while(true)
    swap(leftPtr, rightPtr); // restore pivot, 当 0->right-1 划分好了之后， 交换 rightPtr 和 leftPtr 的位置， 将 pivot 移动到中间
    return leftPtr; // return pivot location
  }
}
```

最初思想中，使用最右为pivot，如果数据本身有序，那么pivot会是最小or最大(数组逆序or正序)，不能起划分作用，效率低下。
(为什么不扫描要排序的全部数据，取中间值，因为这个做法比排序本身还要费时间，不可行)
进一步优化："三数据项取中(median-of-three)"，找数组里第一个，最后一个，中间位置数据项的居中数据项值。
三数据取中的一个好处：可以在第二个内部while循环中取消rightPtr>left的判断(left是数组的最左，避免rightPtr跑出数组)，因为三数据取中时，也对三个数据项进行了排序，已经有序。
还有一个好处：对左端，右端中间的数据项排序之后，划分过程就不需要再考虑这三个数据项了。划分可以从left+1,right-1开始。
再一步提升，使用三数据项取中划分方法，则必须要遵循快速排序算法不能执行三个或者少于三个数据项的划分的规则。数字3被称为切割点。

本例子中处理小划分的方法是manualSort()，代码很简单，只是排序3个数据项或以下的数据。
处理小划分的另一个选择是使用插入排序，数量小插入排序效率也很高。也可以把切割点设定为别的数，推荐使用9.最好的选择取决于计算机，操作系统...等。替换掉recQuickSort()中的if(size <= 3) manualSort()，改用if(size <= 9) insertSort();

```java
class ArrayIns{
    private long[] theArray;
    private int nElems;

    private ArrayIns(int max){
       theArray = new long[max];
       nElems = 0;
    }
    public void insert(long value){
       theArray[nElems] = value;
       nElems++;
    }
    public void quickSort(){
       recQuickSort(0,nElems-1);
    }
    private void recQuickSort(int left,int right){
       int size = right - left + 1;

       if(size <= 3) {
           manualSort(left,right);
       } else {
           long median = median0f3(left,right);
           int partition = partitionIt(left,right,median);
           recQuickSort(left,partition - 1);
           recQuickSort(partition + 1,right);
       }
    }
    private long medianOf3(int left,int right){
       int center = (left + right) / 2;
       if(theArray[left] > theArray[center])  swap(left,center);
       if(theArray[left] > theArray[right])  swap(left,right);
       if(theArray[center] > theArray[right]) swap(center,right);
       swap(center,right - 1);   // put pivot on right
       return theArray[right -1];
    }
    private int partitionIt(int left,int right,long pivot){
       int leftPtr = left;         //right of first elem
       int rightPtr = right -1;    //left of pivot
       while(true){
          while(theArray[++leftPtr] < pivot);
          while(theArray[--rightPtr] > pivot);
          if(leftPtr >= rightPtr ){
             break;
          }  else {
             swap(leftPtr,rightPtr);
          }
       }
       swap(leftPtr,right-1);
       return leftPtr;
    }
    private void manualSort(int left,int right){
       int size = right - left + 1;
       if(size <= 1) return;
       if(size == 2) {
          if(theArray[left] > theArray[right]) swap(left,right);return;
       } else {   //size is 3
          if(theArray[left] > theArray[right -1]) swap(left,right-1);
          if(theArray[left] > theArray[right])  swap(left,right);
          if(theArray[right-1]> theArray[right])  swap(right-1,right);
       }
    }
}
```

也可以选择，对数组整个使用快速排序，不去考虑小于界限的划分的排序。当快速排序结束时，数组已经是基本有序了，然后对整个数组应用插入排序，也是非常快，很多专家推荐这种方法。如，把界限设为10，那么快速排序到10就结束，每一块10个数据里都是无序的，但每一块之间都有序了。再插入排序。

还有一个提升，消除递归。但这是以前计算机性能不好时好用，现在的提升已经不明显了。

## 小敏纸 - 简书

## 程序员的十层楼 —— 周伟民

- 菜鸟。 基本上懂计算机的基本操作， 了解计算机专业的一些基础知识， 掌握一门基本的编程语言。
- 大虾。 熟练掌握一种编程语言， 相关的类库和常见的数据结构和算法。 能自己实现一些简单的功能， 做不了大的东西， 有时候还会遇到疑难问题给卡住。
- 牛人。 
- 大牛
- 专家
- 学者
- 大师
- 科学家
- 大科学家
- 大哲
- 上帝






# Cluause

- 教育的价值在于训练思维， 而不在于传授事实
- 爱的反面不是恨， 是漠然